# CloudWatch Metrics: Standard and Custom

## Original Question
> **What metrics does CloudWatch collect, and how do you define custom metrics?**

## Core Concepts

### Key Definitions
- **Metric**: A fundamental concept in CloudWatch representing a time-ordered set of data points. It is a variable that you monitor, such as the CPU usage of an EC2 instance or the number of processed orders by an application.
- **Namespace**: A container for CloudWatch metrics. Metrics from different services are separated by namespaces. AWS services report to namespaces starting with `AWS/` (e.g., `AWS/EC2`, `AWS/Lambda`). Custom metrics should be placed in a custom namespace (e.g., `MyWebApp/Orders`).
- **Dimension**: A name/value pair that uniquely identifies a metric. You can think of a dimension as a category or label for a metric, allowing you to filter and group data. For example, an EC2 `CPUUtilization` metric can have a dimension of `InstanceId`.
- **Statistic**: A mathematical aggregation of metric data over a specified period, such as `Average`, `Sum`, `Minimum`, `Maximum`, and `SampleCount`.

### Fundamental Principles
- **Infrastructure vs. Application Monitoring**: CloudWatch provides both. Standard metrics primarily cover infrastructure health (the resources your app runs on), while custom metrics are essential for monitoring application-specific and business-level performance.
- **Granularity**: The level of detail in monitoring. For EC2, **Basic Monitoring** provides metrics every 5 minutes, while **Detailed Monitoring** provides them every 1 minute, allowing for faster response times.

## Best Practices & Industry Standards

### Standard Metrics Collected by CloudWatch

CloudWatch automatically collects a wide array of metrics from virtually every AWS service. You do not need to configure anything to receive these standard metrics.

#### Common Examples of Standard Metrics:

-   **For Amazon EC2**:
    -   `CPUUtilization`: The percentage of allocated EC2 compute units that are currently in use.
    -   `NetworkIn` / `NetworkOut`: The number of bytes received on and sent out from all network interfaces.
    -   `DiskReadOps` / `DiskWriteOps`: The number of completed read/write operations from all EBS volumes attached to the instance.
    -   **Note**: Memory usage is *not* a standard metric. It must be collected as a custom metric using the CloudWatch Agent.

-   **For Amazon RDS**:
    -   `DatabaseConnections`: The number of active client network connections to the database instance.
    -   `CPUUtilization`: The percentage of CPU utilization for the database instance.
    -   `FreeableMemory`: The amount of available random access memory.
    -   `ReadLatency` / `WriteLatency`: The average amount of time taken for a read/write I/O operation.

-   **For Application Load Balancer (ALB)**:
    -   `HealthyHostCount` / `UnHealthyHostCount`: The number of healthy/unhealthy targets registered with the load balancer.
    -   `HTTPCode_Target_5XX_Count`: The number of HTTP 5xx server error codes generated by the targets.
    -   `RequestCount`: The total number of requests processed.

-   **For AWS Lambda**:
    -   `Invocations`: The number of times the function is invoked.
    -   `Errors`: The number of invocations that result in an error.
    -   `Duration`: The execution time of the function, in milliseconds.

### Defining Custom Metrics

Custom metrics are essential for gaining visibility into your application's specific performance and business operations. You can publish your own metrics to CloudWatch from any application or service.

#### How to Define and Publish Custom Metrics:

1.  **Choose a Publishing Method**:
    -   **CloudWatch Agent**: The recommended method for collecting system-level metrics (like memory usage, disk space) from EC2 and on-premises servers. You configure the agent to collect these metrics and publish them automatically.
    -   **AWS SDK**: Instrument your application code to publish metrics directly. This is the best way to track application-level KPIs.
    -   **AWS CLI**: Useful for scripting or manual publishing of metrics.

2.  **Structure the Metric Data**: When you publish a custom metric, you must provide:
    -   `Namespace`: A custom namespace to group your metrics (e.g., `MyWebApp/Performance`).
    -   `MetricName`: The name of the metric (e.g., `SuccessfulLogins`, `OrderProcessingTime`).
    -   `Dimensions` (Optional): Key-value pairs to add context (e.g., `Environment=Production`, `Feature=NewCheckout`).
    -   `Value`: The numerical value of the data point.
    -   `Unit` (Optional): The unit of measurement (e.g., `Seconds`, `Count`, `Percent`).

#### Example: Publishing a Custom Metric with the AWS CLI
This command publishes a single data point for a custom metric named `PageLoadTime`.

```bash
aws cloudwatch put-metric-data \
    --namespace "MyWebApp/Performance" \
    --metric-name "PageLoadTime" \
    --dimensions "PageName=HomePage,Region=us-east-1" \
    --value 125.5 \
    --unit "Milliseconds"
```

#### Example: Publishing a Custom Metric with the Python SDK (Boto3)
This is how you would instrument your application code to track a business KPI.

```python
import boto3

cloudwatch = boto3.client('cloudwatch')

def process_new_order(order):
    # ... process the order ...

    # Publish a custom metric for successful orders
    try:
        cloudwatch.put_metric_data(
            Namespace='MyWebApp/Orders',
            MetricData=[
                {
                    'MetricName': 'SuccessfulOrders',
                    'Dimensions': [
                        {
                            'Name': 'ProductCategory',
                            'Value': order['category']
                        },
                        {
                            'Name': 'Environment',
                            'Value': 'Production'
                        }
                    ],
                    'Value': 1,
                    'Unit': 'Count'
                },
            ]
        )
    except Exception as e:
        print(f"Could not publish custom metric: {e}")

```

## Real-World Examples

### Example 1: Monitoring EC2 Memory Usage
**Context**: An operations team needs to monitor the memory utilization of their EC2 fleet, which is not a standard metric.
**Challenge**: Collect and visualize memory usage to set accurate scaling policies.
**Solution**: The **CloudWatch Agent** was installed and configured on all EC2 instances.
-   The agent's configuration file (`config.json`) was set up to collect the `mem_used_percent` metric.
-   It was configured to publish this metric to a custom namespace called `CWAgent/Memory`.
-   A CloudWatch Dashboard was then created to graph this new metric alongside the standard `CPUUtilization` metric, giving a complete picture of instance performance.
**Outcome**: The team gained full visibility into both CPU and memory usage, allowing them to set more intelligent Auto Scaling policies and prevent memory-related application failures.
**Technologies**: CloudWatch Agent, EC2, CloudWatch Custom Metrics.

### Example 2: Tracking a Business KPI
**Context**: An e-commerce application wants to monitor the number of failed payment transactions in real-time.
**Challenge**: Create an immediate alert when the rate of payment failures exceeds a critical threshold.
**Solution**: The application code was instrumented to publish a **custom metric**.
-   Every time the payment processing logic failed, the code would execute a `put_metric_data` call to publish a `PaymentFailure` metric with a value of `1` to the `ECommerce/Payments` namespace.
-   A CloudWatch Alarm was created to monitor the `SUM` of the `PaymentFailure` metric.
-   If the sum of failures exceeded 10 in any 1-minute period, the alarm would trigger an SNS notification to the on-call engineering team.
**Outcome**: The business gained real-time visibility into a critical business process. The team was able to detect and respond to an issue with their payment processor within minutes, rather than hours.
**Technologies**: AWS SDK (for `put_metric_data`), CloudWatch Custom Metrics, CloudWatch Alarms, Amazon SNS.

## Common Pitfalls & Solutions

### Pitfall 1: High Cardinality in Dimensions
**Problem**: Using a dimension with a very high number of unique values (e.g., `UserId`, `OrderId`, `SessionId`).
**Why it happens**: It seems like a good way to get granular data, but it leads to an explosion of unique metrics, making them difficult to analyze and significantly increasing costs.
**Solution**: Use dimensions for broad categories (`Environment`, `Region`, `ApplicationName`), not for unique identifiers. For high-cardinality data, send it to CloudWatch Logs and use Logs Insights or Contributor Insights to analyze it.
**Prevention**: Establish a clear metric and dimension strategy before instrumenting applications.

### Pitfall 2: Forgetting to Install/Configure the CloudWatch Agent
**Problem**: Launching new EC2 instances and having no memory or disk space metrics for them.
**Why it happens**: The agent is not installed on the base AMI, and it's not part of the instance launch script.
**Solution**: Bake the CloudWatch Agent installation and configuration into your standard Amazon Machine Image (AMI). Alternatively, use a launch script (user data) or AWS Systems Manager to automatically install and configure the agent on every new instance.
**Prevention**: Automate infrastructure provisioning and make the CloudWatch Agent a standard component of all compute resources.

## Follow-up Questions Preparation

### Likely Deep-Dive Questions
1.  **"How can you publish metrics from a large number of sources efficiently?"**
    - Instead of having each source call the `PutMetricData` API individually, you can use the **Embedded Metric Format (EMF)**. With EMF, you write your metrics to standard output as a specially formatted JSON blob. The CloudWatch Agent can be configured to recognize this format, and it will automatically extract the metric data and publish it to CloudWatch on your behalf, often more efficiently and cost-effectively.
2.  **"What is the resolution of custom metrics?"**
    - By default, custom metrics are standard resolution (1-minute granularity). However, you can enable **high-resolution** metrics by adding a `StorageResolution` parameter to your `PutMetricData` call. This allows you to publish data at a 1-second resolution, which is useful for monitoring very fast-changing, latency-sensitive applications.

### Related Topics to Be Ready For
- **CloudWatch Agent**: Understanding its configuration file and capabilities.
- **CloudWatch Logs Insights**: The query language used to analyze logs, which is the alternative for high-cardinality data.

### Connection Points to Other Sections
- **Section 6 (CloudWatch Alarms)**: Custom metrics are often the most powerful data sources for creating meaningful alarms.
- **Section 5 (Error Handling)**: An application's error handling framework can be instrumented to publish custom metrics for different error types (e.g., `4XXErrors`, `5XXErrors`).

## Sample Answer Framework

### Opening Statement
"CloudWatch collects a wide range of standard, infrastructure-level metrics from most AWS services automatically, such as CPU utilization for EC2 or request counts for an ALB. However, to get true observability into an application, you must also define and publish custom metrics, which track application-specific or business-level data."

### Core Answer Structure
1.  **Standard Metrics**: Give a few examples of the out-of-the-box metrics CloudWatch collects for key services like EC2 and RDS. Mention that memory is a notable exception that requires an agent.
2.  **Custom Metrics**: Explain *why* custom metrics are needed—to monitor what's happening *inside* the application (e.g., `OrdersProcessed`).
3.  **How to Define**: Describe the process of defining a custom metric by specifying a `Namespace`, `MetricName`, and `Dimensions`.
4.  **How to Publish**: Explain the two primary methods for publishing: using the CloudWatch Agent for system-level metrics like memory, and using the AWS SDK within your application code for business or application-level metrics.

### Closing Statement
"By combining the standard metrics provided by AWS with application-specific custom metrics, you can build a comprehensive monitoring solution that provides visibility into every layer of the stack, from the underlying infrastructure to the end-user experience."

## Technical Deep-Dive Points

### Implementation Details

**CloudWatch Agent Configuration (`config.json`) for Memory and Disk:**
```json
{
  "agent": {
    "metrics_collection_interval": 60,
    "run_as_user": "cwagent"
  },
  "metrics": {
    "namespace": "CWAgent/System",
    "metrics_collected": {
      "mem": {
        "measurement": [
          "mem_used_percent"
        ]
      },
      "disk": {
        "measurement": [
          "disk_used_percent"
        ],
        "resources": [
          "/"
        ]
      }
    },
    "append_dimensions": {
      "InstanceId": "${aws:InstanceId}",
      "AutoScalingGroupName": "${aws:AutoScalingGroupName}"
    }
  }
}
```

### Metrics and Measurement
- **Cost**: Be aware that custom metrics are priced based on the number of metrics stored and the number of API calls (`PutMetricData`). High-frequency, high-cardinality custom metrics can become expensive.
- **Resolution**: Choose the right resolution for your needs. High-resolution (1-second) metrics provide more data but are more expensive than standard-resolution (1-minute) metrics.

## Recommended Reading

### Official Documentation
- [Amazon CloudWatch Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/working_with_metrics.html)
- [Publishing custom metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html)
- [Collect metrics and logs with the CloudWatch agent](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Install-CloudWatch-Agent.html)

### Industry Resources
- [AWS Blog: Getting the most out of Amazon CloudWatch custom metrics](https://aws.amazon.com/blogs/mt/getting-the-most-out-of-amazon-cloudwatch-custom-metrics/)
